---
title: "Caracterización de la pobreza en Chile mediante las variables indicadoras de la encuesta Casen 2017"
subtitle: "EYP2435 - Análisis Multivariado"
format: 
  pdf: 
    include-in-header: 
      text: |
        \usepackage{amsmath}
        \usepackage{float}
    colorlinks: true
    geometry:
      - top=20mm
      - left=20mm
      - right=20mm
      - heightrounded
    fig-pos: "H"
author: 
  - name: "Sebastián Celaya"
  - name: "Camila Echeverría"
crossref:
  fig-title: Figura
  fig-prefix: Figura
  tbl-title: Tabla
  tbl-prefix: Tabla
tbl-cap-location: bottom
---

# Introducción

# Descripción de los datos

Para el desarrollo de nuestro análisis, utilizaremos las distintas variables disponibles en la categoría de índices de la encuesta socioeconómica Casen 2017, cuyos datos se pueden encontrar en [este link](http://observatorio.ministeriodesarrollosocial.gob.cl/encuesta-casen-2017). Estas corresponden a distintos valores que buscan resumir y englobar las distintas características que resultan importantes para representar la situación socioeconómica de las personas y hogares chilenos.

Así, luego de guardar nuestros datos en el archivo `DatosP2.RData`, las variables con las que trabajaremos son las siguientes:

-   `region`: el identificador de cada región.
-   `comuna`: sirve para identificar a qué comuna del país pertenece el hogar.
-   `pobreza`: corresponde a la situación de pobreza por ingresos. Puede ser extremo (1), no extremo (2) o no pobre(0).
- `numper`: número de personas (sin contar personal doméstico) que viven en el hogar.
- `esc`: corresponde al nivel de escolaridad alcanzado.
- `educ`: máximo nivel educacional alcanzado o nivel educacional actual.
- `depen`: dependencia del establecimiento educacional.
- `activ`: condición de actividad de la persona. Puede ser ocupado, desocupado o inactivo.
- `indmat`: indicador de materialidad de la vivienda.
- `indsan`: indicador de saneamiento en el hogar.
- `calglobviv`: calidad global de la vivienda.
- `iae`: el hogar presenta allegamiento externo.
- `iai`: el hogar presenta allegamiento interno.
- `hacinamiento`: existe hacinamiento en la vivienda.
- `ypchautcor`: ingrero individual por persona del hogar corregido.

Las variables `NA` presentes en la base de datos se dan por la manera en que fue diseñada la encuesta. De esta manera, representan la no respuesta o las respuestas en blanco. Es por esto que, en la mayoría de los casos, fueron reemplazadas por el valor 0 o algo similar para indicar que, en realidad, la pregunta no aplica a la persona en cuestión.

# Metodologías

Para poder corroborar o descartar nuestra hipótesis, es importante que, en primer lugar, realicemos un análisis exploratorio de nuestros datos. Como en su mayoría contamos con variables categóricas, veremos cómo se comportan éstas en términos de proporción poblacional en cada una de las regiones del país, para ver si resulta más conveniente trabajar con la variable `region` o eliminarla por completo de nuestro análisis.

Para poder tener una muestra más balanceada, realizaremos un muestreo aleatorio simple donde seleccionaremos a 20 mil personas en situación de pobreza (ya sea extrema o no) y 20 mil personas en situación de no pobreza.

Luego de esto, llevaremos a cabo un análisis factorial para reducir la dimensionalidad de nuestras variables y determinar cuántos factores necesitaremos para explicar entre un 70% y un 90% de la varianza total. Así, utilizaremos estos factores para modelar una regresión logística que sea capaz de caracterizar a la gente como no pobre (0) o pobre(1). Analizaremos los distintos estadísticos y elementos de esta regresión para determinar qué tan buen modelo es y si cumple con la suficiencia necesaria.

Finalmente, y con estos mismos factores, intentaremos llevar a cabo una regresión lineal donde la variable a predecir sea el ingreso autónomo per cápita del hogar corregido, donde calcularemos los distintos valores que describen la calidad de ajuste del modelo.

# Resultados

En el análisis exploratorio regional obtendremos los siguientes resultados:

## Análisis de pobreza por Región:

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
# Librerias
library(rio)
library(tidyverse)
library(tidyr)
library(corrplot)
library(ggforce)
library(scales)
library(raster)
library(rworldxtra)
library(sf)
library(ggrepel)
library(vcd)
# Mapa
rm <- chilemapas::mapa_comunas %>% 
  filter(codigo_region == 13)

chile <- chilemapas::generar_regiones()
names(chile)[1] <- "region"

names(rm)[1] <- "comuna"
# Carga
load("DatosP2.RData")
datos2 <- datos1 %>% 
  mutate(region = as.character(region),
         comuna = as.character(comuna)) 

datos2$pobreza[is.na(datos2$pobreza)] = 0

datos2$region <- recode(datos2$region, "1" = "01", "2" = "02", "3" = "03", 
                        "4" = "04", "5" = "05", "6" = "06", "7" = "07", 
                        "8" = "08", "9" = "09")

personas <- datos2 %>% count(region)

p.region <- datos2 %>% count(region, pobreza) 

p.region <- left_join(p.region, personas, by = "region") %>% 
  mutate(prop = n.x/n.y*100) %>% 
  dplyr::select(region, pobreza, prop)
```

Como se puede observar en @fig-1-1 la mayor porcentaje de pobreza extrema es la región de la Araucanía (IX Región) seguida de la región de Ñuble (XVI Región). Además podemos observar que las regiones de Aysén (XI), Magallanes (XII), Metropolitana (XIII) y Antofagasta (II) poseen la menor porcentaje de pobres extremos.

Ahora analizando @fig-1-2 se muestra aquellas regiones con pobreza no extrema, y observamos que son las mismas mencionadas anteriormente, al igual que las regiones que poseen menor porcentaje de pobreza no extrema.

Después de observar las figuras anteriores, al analizar @fig-1-3 es ocurre lo que era de esperar sobre las regiones con mayor porcentaje de no pobreza, aquellas regiones que obtuvieron una baja porcentaje de pobreza, valga la redundancia, tienen alta porcentaje de no pobreza y viceversa.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-1
#| fig-cap: "Pobreza por regiones"
#| fig-subcap: 
#|         - "Extrema"
#|         - "No extrema"
#|         - "No pobreza"
#| layout: [[1,1,1]]

left_join(chile, p.region[which(p.region$pobreza == 1),]) %>%
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  col = "black", size = 3, max.overlaps = 22) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "green", high = "red", na.value = NA)

left_join(chile, p.region[which(p.region$pobreza == 2),]) %>%
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  col = "black", size = 3, max.overlaps = 22)  +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "green", high = "red", na.value = NA)

left_join(chile, p.region[which(p.region$pobreza == 3),]) %>%
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  col = "black", size = 3, max.overlaps = 22)  +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "red", high = "green", na.value = NA)
  
```

## Análisis de indice de actividad por Región:

De @fig-2-1 podemos observar que las regiones de Aysén (XI), Magallanes (XII) y Metropolitana (XIII) tiene mayor porcentaje de personas ocupadas, es decir, personas que durante la semana de referencia de la encuesta realizaron una actividad a cambio de remuneración o beneficios. De @fig-2-2 logramos ver que la región Arica y Parinacota (XV), Coquimbo (IV) y Biobio (VIII) presentan mayor porcentaje de desocupados, es decir, personas que no son ocupadas, pero durante las 4 últimas semanas han estado en busqueda de un puesto de trabajo. Por último de @fig-2-3 podemos observar que la región de Coquimbo (IV) y Biobio (VII) muestran mayor proporcion de personas inactivas, es decir, personas que no son ocupadas, ni desocupadas.

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
datos3 <- datos1 %>% 
  mutate(region = as.character(region),
         comuna = as.character(comuna)) 

datos3$activ[is.na(datos3$activ)] = 0

datos3$region <- recode(datos3$region, "1" = "01", "2" = "02", "3" = "03", 
                        "4" = "04", "5" = "05", "6" = "06", "7" = "07", 
                        "8" = "08", "9" = "09")

personas <- datos3 %>% count(region)

p.region <- datos3 %>% count(region, activ) 

p.region <- left_join(p.region, personas, by = "region") %>% 
  mutate(prop = n.x/n.y*100) %>% 
  dplyr::select(region, activ, prop)
```

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-2
#| fig-cap: "Índice de actividad por regiones"
#| fig-subcap: 
#|         - "Ocupados"
#|         - "Desocupados"
#|         - "Inactivos"
#| layout: [[1,1,1]]

left_join(chile, p.region[which(p.region$activ==1),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49)  +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "green", high = "orange", na.value = NA)

left_join(chile, p.region[which(p.region$activ==2),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49)  +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "green", high = "orange", na.value = NA)

left_join(chile, p.region[which(p.region$activ==3),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49)  +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "white", high = "red", na.value = NA)
```

## Análisis de ingresos por Región:

Para este analisis usaremos 2 medidas de los ingresos, la media de estos y la mediana. Debido a que la media está sesgada por los valores extremos, en este caso las personas que tienen ingresos muy altos afectan al promedio, es por ello que también usaremos la mediana. De @fig-3-1 logramos divisar que la mayor media de los ingresos se encuentra principalmente en la región Metropolitana (XIII) con un ingreso promedio mayor de 400.000 pesos, seguida de la región de Magallanes (XII). Pero analizando la @fig-3-2 donde se presentan las medianas de los ingresos totales de las personas por región podemos ver que la región de Magallanes (XII) presenta mayor mediana de ingresos (más de 240.000 pesos), mientras que la región Metropolitana (XIII) tiene una mediana de ingresos entre 200.000 pesos y 240.000 pesos. Con este caso de la región Metropolitana podemos analizar esta región para tener una visión de lo que pasa al interior de esta.

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
datos4 <- datos1 %>% 
  mutate(region = as.character(region),
         comuna = as.character(comuna)) 

datos4$region <- recode(datos4$region, "1" = "01", "2" = "02", "3" = "03", 
                        "4" = "04", "5" = "05", "6" = "06", "7" = "07", 
                        "8" = "08", "9" = "09")

p.region <- datos4 %>% group_by(region) %>% 
  summarise(media = mean(ypchautcor), mediana = median(ypchautcor))

```

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE, }
#| label: fig-3
#| fig-cap: "Ingresos por regiones"
#| fig-subcap: 
#|         - "Medios"
#|         - "Medianos"
#| layout: [[1,1]]


left_join(chile, p.region) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = media)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49)  +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "white", high = "darkgreen", na.value = NA)

left_join(chile, p.region) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = mediana)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "white", high = "darkgreen", na.value = NA)
```

\newpage

Analizando lo que ocurre en la región metropolitana separando por comunas obtenemos las @fig-4-1 y @fig-4-2. De @fig-4-1 observamos que la comuna de vitacura es la que presenta ingresos medios mayores a 1.250.000 pesos, por lo tanto esta comuna es la que ingrementa la media de los ingresos en la región Metropolitana. Mientras que las demás comunas tienen un ingreso medio cercano a los 250.000 pesos.

Analizando la @fig-4-2 volvemos a observar que vitacura tiene la mayor mediana de los ingresos (más de 1.000.000 de pesos), después le sigen la comuna de Providencia y Las Condes con mediana de ingresos entre 750.000 y 1.000.000 pesos. Además, igual que en @fig-4-1 podemos apreciar que a excepción de estas comunas la mayoría tiene un ingreso (ya sea por media o mediana) cercano a 250.000 pesos. Por lo tanto es un aspecto a considerar que en santiago es un sector el cual presenta mayores ingresos, lo que afecta en la comparación entre los ingresos de las regiones.

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
datos4rm <- datos4 %>% 
  filter(region=="13")

p.rm <- datos4rm %>% group_by(comuna) %>% 
  summarise(media = mean(ypchautcor), mediana = median(ypchautcor))
```

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-4
#| fig-cap: "Ingresos por comunas de Santiago"
#| fig-subcap: 
#|         - "Medios"
#|         - "Medianos"
#| layout: [[1,1]]


left_join(rm, p.rm) %>% 
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = media)) + 
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "white", high = "darkgreen", na.value = NA)

left_join(rm, p.rm) %>% 
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = mediana)) + 
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "white", high = "darkgreen", na.value = NA)
```

\newpage

## Análisis educacional por Región:

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
datos5 <- datos1 %>% 
  mutate(region = as.character(region),
         comuna = as.character(comuna)) %>% 
  filter(educ != 99)

datos5$educ[is.na(datos5$educ)] = 0

datos5$region <- recode(datos5$region, "1" = "01", "2" = "02", "3" = "03", 
                        "4" = "04", "5" = "05", "6" = "06", "7" = "07", 
                        "8" = "08", "9" = "09")

personas <- datos5 %>% count(region)

p.region <- datos5 %>% count(region, educ) 

p.region <- left_join(p.region, personas, by = "region") %>% 
  mutate(prop = n.x/n.y*100) %>% 
  dplyr::select(region, educ, prop)
```

De @fig-5 podemos observar que las regiones de Aysén (XI) y Tarapacá (I) presentan mayor porcentajes de personas que no completaron ningún nivel de educación. Luego la región de Magallanes (XII) es la menor porcentaje de personas que no completaron ningún nivel educacional.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-5
#| fig-cap: "Porcentaje de personas sin educación por región"
#| layout: [[-20,60,-20]]

left_join(chile, p.region[which(p.region$educ==0),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "blue", high = "darkorange", na.value = NA)
```

De @fig-6-1 se visualiza que las regiones de Maule (VIII), La Araucanía (IX) y de Los Lagos (X) presentan mayor porcentaje de personas que no han terminado la enseñanza básica. Es importante destacar que los porcentajes de personas que no terminaron la básica fue mayor al 24%, una cifra importante a considerar. También podemos observar que las regiones de Arica y Parinacota (XV), Tarapacá (I), Antofagasta (II), Metropolitana (XIII) y Magallanes (XII) con menor porcentaje de personas que no han terminado la básica.

De @fig-6-2 se visualiza que la región Libertador General Bernardo O'Higgins (VI) con el mayor porcentaje de personas que solo tienen terminada la enseñanza básica, mientras que las regiones de Arica y Parinacota (XV), Tarapacá (I), antofagasta(II), Metropolitana (XIII) y Magallanes (XII) como las regiones con menor porcentaje de personas que llegaron a completar la enseñanza básica.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-6
#| fig-cap: "Porcentaje de personas con educación básica"
#| fig-subcap: 
#|         - "Incompleta"
#|         - "Completa"
#| layout: [[1,1]]


left_join(chile, p.region[which(p.region$educ==1),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "blue", high = "darkorange", na.value = NA)

left_join(chile, p.region[which(p.region$educ==2),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(high = "blue", low = "darkorange", na.value = NA)
```

\newpage

De @fig-7-1 se observa que La región de Tarapacá (II) y Metropolitana (XIII) tienen mayor porcentaje de personas que no llegaron a completar la enseñanza media en un colegio/instituto humanista, mientras que las regiones de Magallanes (XII) y Libertador General Bernardo O'Higgins (VI) las regiones con menor porcentaje de personas que no completaron la enseñanza media en un colegio/instituto humanista.

De @fig-7-2 se logra apreciar que la región de Tarapacá (II), La Araucanía (IX) y Magallanes (XII) presentan mayor porcentaje de personas que no llegaron a completar la enseñanza media en un instituto Técnico Profesional. Mientras que las regiones de Aysén (XI), Ñuble(XVI) y Valparaíso (V) el menor porcentaje de personas que no llegaron a completar la enseñanza media en un instituto profesional.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-7
#| fig-cap: "Porcentaje de personas con educación media incompleta por región"
#| fig-subcap:
#|         - "Humanista"
#|         - "Técnico Profesional"
#| layout: [[1,1]]
left_join(chile, p.region[which(p.region$educ==3),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "blue", high = "darkorange", na.value = NA)

left_join(chile, p.region[which(p.region$educ==4),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "blue", high = "darkorange", na.value = NA)
```

De @fig-8-1 logramos observar que la región de Antofagasta (II) es la que presenta major porcentaje de personas que completaron la enseñanza media en colegios/institutos humanistas, mienytas que las regiones de la zona sur y un poco del centro (Magallanes, Aysén, Los Lagos, La araucanía, Los Rios, Maule, Biobio, Ñuble) tienen un menor porcentaje de personas que completaron la enseñanza media en colegios humanistas.

Tenemos que @fig-8-2 se ve que las regiones de Tarapacá (II) y Magallanes (XII) presentan mayor porcentaje de personas que completaron la enseñanza media en institutos Técnicos Profesionales. Mientras que la región de Aysén (XI) es la que presenta menor porcentaje de personas que terminaron la enseñanza media en institutos Técnicos Profesionales.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-8
#| fig-cap: "Porcentaje de personas con educación media completa por región"
#| fig-subcap:
#|         - "Humanista"
#|         - "Técnico Profesional"
#| layout: [[1,1]]
left_join(chile, p.region[which(p.region$educ==5),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(high = "blue", low = "darkorange", na.value = NA)

left_join(chile, p.region[which(p.region$educ==6),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(high = "blue", low = "darkorange", na.value = NA)
```

Observando @fig-9-1 obtenemos que las regiones de Antofagasta (II), Valparaiso (V), Metropolitana (XIII) y Magallanes (XII) con mayor porcentaje de personas que tienen educación Técnica incompleta. Cabe notar que este porcentaje es uno de los más bajos (no supera el 3,5%). Mientras que las regiones de Los Rios (XIV) y La araucanía (IX) presentan el menor porcentaje de personas con educación Técnica incompleta.

Analizando @fig-9-2 presenta mayor porcentaje de personas con educación Técnica completa la región de Magallanes (XII). mientras que múltiples regiones de la zona centro y sur (Tarapacá, Coquimbo, Maule, La Araucanía, Los Rios y Los Lagos) tienen menor porcentaje de personas que completaron la educación Técnica.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-9
#| fig-cap: "Porcentaje de personas con educación técnica por región"
#| fig-subcap:
#|         - "Incompleta"
#|         - "Completa"
#| layout: [[1,1]]
left_join(chile, p.region[which(p.region$educ==7),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "blue", high = "darkorange", na.value = NA)

left_join(chile, p.region[which(p.region$educ==8),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(high = "blue", low = "darkorange", na.value = NA)
```

\newpage

Revisando @fig-10-1 se logra ver que las regiones de Antofagasta (II), Valparaiso (V), Metropolotana (XIII) y Ñuble (XVI) presentan mayor porcentaje de personas que tienen estudios profesionales incompletos. Por contraparte, las regiones de Coquimbo (IV) y Aysén (XI) presentan el menor porcentaje de personas con estudios profesionales incompletos.

Observando @fig-10-2 podemos denotar que la región Metropolitana (XIII) es la única región con mayor porcentaje de personas con postgrados incompletos. Mientras que las demás regiones sus porcentajes son menores al 0.3%. Es interesante, igualmente, ver que este porcentaje no es mayor al 0.5% todos y que el más alto está en la región metropolitana.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-10
#| fig-cap: "Porcentaje de personas con educación profesional por región"
#| fig-subcap:
#|         - "Incompleta"
#|         - "Completa"
#| layout: [[1,1]]
left_join(chile, p.region[which(p.region$educ==9),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "blue", high = "darkorange", na.value = NA)

left_join(chile, p.region[which(p.region$educ==10),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "blue", high = "darkorange", na.value = NA)
```

De @fig-11-1 podemos ver que el mayor porcentaje de personas que completaron estudios profesionales se encuentran concentrada en la región Metropolitana (XIII), seguida de la región de Magallanes (XII) con no más de 10%. Todas las demás regiones tienen un porcentaje menor a 8%.

Finalmente un caso muy interesante de analizar, en @fig-11-2, observaremos el porcentaje de personas que terminaron un postgrado. De esta figura vemos una concentración extrema en la región Metropolitana (XIII), donde hay más de un 2% de personas que completaron un postgrado. Todas las demás regiones tienen menos de un 0.5% de personas con un postgrado completo. De esta información, al igual que los ingresos totales, analizaremos que sucede en la región Metropolitana según comunas.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-11
#| fig-cap: "Porcentaje de personas con profesional completo por región"
#| fig-subcap:
#|         - "Incompleta"
#|         - "Completa"
#| layout: [[1,1]]
left_join(chile, p.region[which(p.region$educ==11),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(high = "blue", low = "darkorange", na.value = NA)

left_join(chile, p.region[which(p.region$educ==12),]) %>% 
  mutate(centroid = map(geometry, st_centroid), 
         coords = map(centroid, st_coordinates), 
         coords_x = map_dbl(coords, 1), 
         coords_y = map_dbl(coords, 2)) %>%
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  coord_sf(xlim = c(-77, -65)) +
  geom_text_repel(mapping = aes(coords_x, 
                                coords_y, 
                                label = region),
                  max.overlaps = 49) +
  labs(x = "", y = "") +
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(high = "blue", low = "darkorange", na.value = NA)
```

\newpage

Analizando el caso particular de Santiago sobre las personas que tienen un postgrado completo obtendremos la @fig-12

De @fig-12 podemos observar que existen comunas que no tienen personas que completaron un postgrado, que la mayoría tiene menos de un 2,5% de personas con un postgrado, y más importante que existen 3 comunas donde hay cerca de un 10% de personas con un postgrado, y exactamente esas comunas son Vitacura, Providencia y Las condes, la cuales son las 3 comunas con el ingreso más alto según @fig-2. Entonces podemos suponer que esta comuna presenta ingresos altos debido a las personas con postgrado completo. Esta idea se fortalece debido al conocimiento popular que las personas que estudian un postgrado tiene sueldo mucho mayor al de las demás personas.

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}

p.com <- datos5 %>% filter(region == 13) %>% count(comuna, educ) 

personas <- datos3 %>% filter(region == 13) %>% count(comuna)

p.com <- left_join(p.com, personas, by = "comuna") %>% 
  mutate(prop = n.x/n.y*100) %>% 
  dplyr::select(comuna, educ, prop)

p.com = p.com %>% filter(educ == 12)
```

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-12
#| fig-cap: "Porcentaje de personas con Postgrado completo por comunas de Santiago"
#| layout: [[-20,60,-20]]
left_join(rm, p.com) %>% 
  ggplot() +
  geom_sf(aes(geometry = geometry, fill = prop)) + 
  theme_bw() +
  theme(axis.text.x = element_blank(), # Eliminar ejes
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  scale_fill_gradient(low = "darkorange", high = "blue", na.value = NA)
```

\newpage

Con todos los datos anteriores podemos ver semejanzas, de que existen una relación entre los ingresos, la pobreza, la demografía, los estudios, entre otros. Tal como muestra @fig-13 con las correlaciones de las variables ocupadas.

Podemos observar en @fig-13 la correlación que existe entre la variable de Allegamiento Interno y la variable de número de personas en el hogar, la variable de escolaridad y condición de actividad, hacinamiento y Allegamiento Externo, entre otros.

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
load("DatosP2.RData")

datos1[is.na(datos1)] <- 0


## Para balancear la muestra, consideramos a 20 mil personas no pobres al azar y 20 mil personas pobres (extremas y no extremas) al azar.
muestra <- function(datos){
  pobres <- which(datos$pobreza %in% c(1,2))
  nopobres <- which(datos$pobreza==3)
  
  n1 <- sample(pobres, 20000)
  n2 <- sample(nopobres, 20000)
  n <- sort(c(n1,n2))
  
  datitos <- datos[n,]
  
  return(datitos)
}

datazo <- muestra(datos1)

ingreso <- datazo[,14]
pobreza <- recode(datazo[,13], `1` = "1", `2` = "1", `3` = "2")
salmon <- datazo[,-c(13,14)]

sigma <- cor(scale(salmon))

valp <- eigen(sigma)$values
vecp <- eigen(sigma)$vectors

prop.var <- valp/sum(valp)
```

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-13
#| fig-cap: "Correlograma de las variables"
corrplot::corrplot(sigma)
```

Con estos datos se puede plantear un modelo factorial (Debido a que tratamos con variables categóricas), con ellos poder ver cuanto son las cantidades de factores necesarios para describir el modelo con la mayor variablidad posible.

Tal como describimos en ***Metodología***, utilizaremos el método de varianza explicada por factores. Tal como muestra @fig-14 se muestra el porcentaje de varianza explicada por cada factor.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-14
#| fig-cap: "Porcentaje de varianza explicada por cada factor"
#| layout: [[-20,60,-20]]
cbind(Factores = 1:12,
      Varianzas = prop.var) %>%
  as.data.frame() %>%
  ggplot()+
  theme_bw() +
  geom_point(aes(Factores, Varianzas)) +
  scale_x_continuous(breaks = c(1:12),
                     labels = 1:12)
```

Con @fig-14 mostramos la varianza explicada por cada factor, a simple vista no logramos observar la cantidad de factores necesarios según el criterio de varianza explicada. Es por esta razón que creamos @fig-15 donde se muestran las varianzas explicadas por los factores acumulados, es decir la varianza explicado por el factor más todos los que le anteceden.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-15
#| fig-cap: "Porcentaje de varianza explicada por cada factor acumulado"
#| layout: [[-20,60,-20]]
cbind(Factores = 1:12,
      Varianzas = cumsum(prop.var)) %>%
  as.data.frame() %>%
  ggplot()+
  theme_bw() +
  geom_point(aes(Factores, Varianzas)) +
  scale_x_continuous(breaks = c(1:12),
                     labels = 1:12) +
  geom_hline(yintercept = 0.70, col = "red", lwd = 1) +
  geom_hline(yintercept = 0.90, col = "red", lwd = 1) +
  geom_segment(x = 8, y = 0,
               xend = 8, yend = cumsum(prop.var)[8],
               color = "blue",
               linetype = 2,
               lwd = 1) +
  geom_segment(x = 0, y = cumsum(prop.var)[8],
               xend = 8, yend = cumsum(prop.var)[8],
               color = "blue",
               linetype = 2,
               lwd = 1)+
  geom_text(x = 8.5, 
            y = cumsum(prop.var)[8], 
            label = round(cumsum(prop.var)[8], 2),
            col = "blue", size = 2)
```

Como podemos observar en @fig-15 dado que buscamos una varianza explicada entre un 70% y 90%. Con ese intervalo vemos que con 8 factores tenemos la mayor varianza explicada que se encuentra dentro del rango acordado. Con un total de 8 factores logramos explicar el 86%.

Por ello nos quedaremos solamente con 8 factores. Usando este nuevo modelo, obtendremos la @fig-16 donde se muestran las varianzas y varianzas acumuladas de cada factor.

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
# Así, nos quedamos únicamente con 8
valp <- eigen(sigma)$values[1:8]
vecp <- eigen(sigma)$vectors[,1:8]

prop.var <- valp/sum(valp)
```

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-16
#| fig-cap: "Varianza explicada por cada factor"
#| fig-subcap:
#|         - "Varianza"
#|         - "Varianza acumulada"
#| layout: [[1,1]]
cbind(Factores = 1:8,
      Varianzas = prop.var) %>%
  as.data.frame() %>%
  ggplot()+
  theme_bw() +
  geom_point(aes(Factores, Varianzas)) +
  scale_x_continuous(breaks = c(1:8),
                     labels = 1:8)

cbind(Factores = 1:8,
      Varianzas = cumsum(prop.var)) %>%
  as.data.frame() %>%
  ggplot()+
  theme_bw() +
  geom_point(aes(Factores, Varianzas)) +
  scale_x_continuous(breaks = c(1:8),
                     labels = 1:8)
```

\newpage

Ya con la cantidad de factores elegidos y la variabilidad explicada de cada uno, ahora podemos analizar las correlaciones de cada factor (o componente) con las variables como muestra la @fig-17

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
correlaciones <- function(valp, vecp, sigma){
  r <- matrix(1, nrow=12)
  for(i in 1:8){
    r <- cbind(r, vecp[,i]*sqrt(valp[i]/sigma[i,i]))
  }
  
  return(r[,-1])
}

r <- correlaciones(valp, vecp, sigma)
rownames(r) <- colnames(datos1)[-c(13,14)]
colnames(r) <- paste0("r", 1:8)

```

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-17
#| fig-cap: "Correlaciones entre componentes y variables"
#| layout: [[-20,60,-20]]
data.frame(r) %>% ggplot(aes(x=1:12)) +
  geom_line(aes(y=r1, color = "r1"), size = 1.5) +
  geom_line(aes(y=r2, color = "r2"), size = 1.5) +
  geom_line(aes(y=r3, color = "r3"), size = 1.5) +
  geom_line(aes(y=r4, color = "r4"), size = 1.5) +
  geom_line(aes(y=r5, color = "r5"), size = 1.5) +
  geom_line(aes(y=r6, color = "r6"), size = 1.5) +
  geom_line(aes(y=r7, color = "r7"), size = 1.5) +
  geom_line(aes(y=r8, color = "r8"), size = 1.5) +
  theme_bw() +
  labs(title = "Correlaciones de las componentes principales con las variables",
       color = "Componentes") +
  scale_color_manual(values = rainbow(8)) +
  scale_x_continuous(breaks = c(1:12),
                     labels = 1:12)
```

Podemos apreciar de @fig-17 que tenemos muchas variablidad de casos, hay algunos componentes que estan muy corrrelacionados con las variables, como es el caso del primer componente con las primeras 2 variables, el sexto componente con la sexta variable, tomaremos como muy correlacionados aquellos componentes con correlación mayor a 0.5 y menor a -0.5 de la @fig-17. También existen componentes que no estan correlacionados con algunas variables, como es el caso de todos los que se encuentran entre -0.5 y 0.5 de la @fig-17.

Con este modelo podemos observar que tanto explica el modelo a cada variable por separado. Tal como muestra la @fig-18

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-18
#| fig-cap: "variabilidad explicada del modelo por cada variable"
#| layout: [[-20,60,-20]]
## Varianza explicada para cada variable
var_exp = as.data.frame(rowSums(r^2))
var_exp = var_exp %>%
  mutate(variable = rownames(var_exp))
colnames(var_exp) = c("suma", "var")

var_exp %>%
  ggplot(aes(x = var, y = suma))+
  geom_bar(stat = "identity", position = "stack", width=0.5, fill = "purple") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

Ya con todos los datos evaluados y vemos que podemos trabajar con las 8 componentes principales que obtuvimos. Ahora ha llegado el momento de generar una regresión logística con los 8 componentes principales como planteamos en el enunciado.

## Regresión logística

Utilizando los 8 componentes para poder predecir el índice de pobreza, agrupando a las personas pobres no extremas y pobres extremas en el mismo grupo, pobre.

Al generar un modelo logístico obtenemos los valores de significancia que muestra @tbl-1.

```{r, echo = FALSE}
#| label: tbl-1
#| tbl-cap: "Resultados obtenidos"
a <- as.matrix(salmon)%*%vecp
suma <- rowSums(a)

b <- data.frame(a, pobreza)

c = data.frame(b) %>%
  mutate(pobreza = case_when(
    pobreza == "1" ~ 1,
    pobreza == "2" ~ 0
  ))

modelo_glm <- glm(pobreza ~ ., 
                  data = c,
                  family = "binomial")

primodenoruega <- summary(modelo_glm)[["coefficients"]]

knitr::kable(primodenoruega, align = "c", digits = 3)
```

Por @tbl-1 observamos que nuestros 8 componentes principales son significativos para predecir la pobreza. Ahora para cada componentes junto con el intercepto, se calculará el intervalo de confianza para estimarlos. Tal como muestra @tbl-2 de esta manera quedan estimados los coeficientes con una confianza del 95%.

\newpage

```{r, message = FALSE, results = TRUE, warning = FALSE, echo = FALSE}
#| label: tbl-2
#| tbl-cap: "Intervalos de confianza obtenidos"
int_conf = confint(modelo_glm)

knitr::kable(int_conf, align = "c", digits = 3)
```

Finalmente se obtendrá la cantidad

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-19
#| fig-cap: "Mosaico de predicciones y valores reales del modelo logístico"
#| layout: [[-20,60,-20]]
predicciones <- ifelse(test = modelo_glm$fitted.values > 0.5, yes = 1, no = 0)
matriz_confusion <- table(modelo_glm$model$pobreza, predicciones,
                          dnn = c("observaciones", "predicciones"))
mosaic(matriz_confusion, shade = TRUE, colorize = TRUE,
       gp = gpar(fill = matrix(c("green3", "red2", "red2", "green3"), 2, 2)))
```

\newpage

## Regresión lineal

Ahora usaremos los 8 componentes principales para generar una regresión lineal para poder estimar los ingresos totales. Luego de crear este modelo con los 8 componentes principales, compararemos con modelos sin alguno de estos componentes y compararemos los AIC de los modelos, tal como muestra @fig-20.

```{r, include = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = FALSE}
d = data.frame(cbind(a, ingreso))

modelo_lm = lm(ingreso ~.,
               data = d)
pasos = step(object = modelo_lm, direction = "both", trace = 1)

# Generamos otros modelos posibles

modelo_lm1 = lm(ingreso ~ .-V1,
               data = d)
modelo_lm2 = lm(ingreso ~ .-V2,
               data = d)
modelo_lm3 = lm(ingreso ~ .-V3,
               data = d)
modelo_lm4 = lm(ingreso ~ .-V4,
               data = d)
modelo_lm5 = lm(ingreso ~ .-V5,
               data = d)
modelo_lm6 = lm(ingreso ~ .-V6,
               data = d)
modelo_lm7 = lm(ingreso ~ .-V7,
               data = d)
modelo_lm8 = lm(ingreso ~ .-V8,
               data = d)



AICS = c(AIC(modelo_lm),
         AIC(modelo_lm1),
         AIC(modelo_lm2),
         AIC(modelo_lm3),
         AIC(modelo_lm4),
         AIC(modelo_lm5),
         AIC(modelo_lm6),
         AIC(modelo_lm7),
         AIC(modelo_lm8))

compara = cbind(modelo = c("Modelo completo", 
                           "Modelo -primer comp",
                           "Modelo -segundo comp",
                           "Modelo -tercero comp",
                           "Modelo -cuarto comp",
                           "Modelo -quinto comp",
                           "Modelo -sexto comp",
                           "Modelo -septimo comp",
                           "Modelo -octavo comp"), 
                aic = round(AICS, 0)) %>%
  as.data.frame()

compara$modelo = factor(compara$modelo, 
                        levels = c("Modelo completo", 
                                   "Modelo -primer comp",
                                   "Modelo -segundo comp",
                                   "Modelo -tercero comp",
                                   "Modelo -cuarto comp",
                                   "Modelo -quinto comp",
                                   "Modelo -sexto comp",
                                   "Modelo -septimo comp",
                                   "Modelo -octavo comp"))

```

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-20
#| fig-cap: "AIC de los modelos"
#| layout: [[-20,60,-20]]
compara %>%
  ggplot()+
  geom_bar(aes(x = modelo, y = aic), stat = "identity", fill = "blue") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

Según @fig-20, el modelo completo es aquel que presenta menor criterio de información de Akaike (AIC), por lo tanto es correcto utilizar estos 8 componentes.

Analizando los coeficientes de la regresión lineal obtenemos lo visto en @tbl-3.

```{r, echo = FALSE}
#| label: tbl-3
#| tbl-cap: "Resultados obtenidos"
ust <- summary(modelo_lm)[["coefficients"]]

knitr::kable(ust, align = "c", digits = 3)
```

Viendo @tbl-3 podemos observar que el tercer componente resultó no ser tan significatio como el resto, pero como ya comprobamos, si lo eliminamos aumenta el AIC. Pese a no ser tan significante como el resto. Ahora, ya analizado los coeficientes, vamos a crear un intervalo de confianza para cada coeficiente. A continuación, en @tble-4 se mostrará los intervalos de confianza de cada uno.

```{r, message = FALSE, results = TRUE, warning = FALSE, echo = FALSE}
#| label: tbl-4
#| tbl-cap: "Intervalos de confianza obtenidos"
int_conf = confint(modelo_lm)

knitr::kable(int_conf, align = "c", digits = 3)
```

Sin embargo, pese a que la cantidad de componentes que genera el modelo es el más eficiente, el modelo no es buen predictor debido a la existencia de valores atípicos. Estos valores atípicos no permiten ajustar el modelo de la mejor manera posible, esto se logra apreciar a travez de la @fig-21.

```{r, message = FALSE, results = FALSE, warning = FALSE, echo = FALSE}
#| label: fig-21
#| fig-cap: "Q-Q Plot del modelo"
#| layout: [[-20,60,-20]]
qqnorm(modelo_lm$residuals)
qqline(modelo_lm$residuals, col = "red", lwd = 2)
```

Con @fig-21, se muestra claramente que existen una cantidad considerable de datos atípicos, los cuales aumentan los residuos del modelo. Tal como analizamos anteriormente, cuando hablamos de ingresos en chile, existe un grupo (concentrado en la comuna de vitacura) el cual tiene ingresos elevados.

\newpage

# Conclusión

Tras realizar un análisis factorial logramos crear 12 factores. De los 12 factores, por criterio de varianza explicada, calculamos que con los 8 primeros factores son capaces de explicar suficiente varianza de los datos. Con esos 8 componentes principales se pudo reducir la dimensionalidad de los datos, y poder crear un modelo logístico que ____________________, el cual los 8 componentes principales resultaron significativos y el modelo fue capaz de predecir de manera muy acertada.
Además, se comprobó que no es posible realizar un análisis de regresión lineal el cual intente explicar los ingresos totales. Al analizar los ingresos se observa que existe una importante cantidad de 


\newpage

# Conclusión

En conclusión, el Emiliano vale pico, pero no tanto como Aravena.

# Bibliografía (EDITAR DESPUÉS)

1.  Chung-hong Chan, Geoffrey CH Chan, Thomas J. Leeper, and Jason Becker (2021). rio: A Swiss-army knife for data file I/O. R package version 0.5.29.
2.  Hijmans R (2022). _raster: Geographic Data Analysis and Modeling_. R package version 3.6-11, <https://CRAN.R-project.org/package=raster>.
3.  Libro de códigos Base de Datos Casen 2017
4.  Meyer D, Zeileis A, Hornik K (2006). “The Strucplot Framework: Visualizing Multi-Way Contingency Tables with vcd.” _Journal of Statistical Software_, *17*(3), 1-48. doi:10.18637/jss.v017.i03 <https://doi.org/10.18637/jss.v017.i03>
5.  Pebesma, E., 2018. Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal 10 (1), 439-446, https://doi.org/10.32614/RJ-2018-009
6.  Pedersen T (2022). _ggforce: Accelerating 'ggplot2'_. R package version 0.4.1, <https://CRAN.R-project.org/package=ggforce>.
7.  Slowikowski K (2022). _ggrepel: Automatically Position Non-Overlapping Text Labels with 'ggplot2'_. R package version 0.9.2, <https://CRAN.R-project.org/package=ggrepel>.
8.  South A (2012). _rworldxtra: Country boundaries at high resolution._. R package version 1.01, <https://CRAN.R-project.org/package=rworldxtra>
9.  Taiyun Wei and Viliam Simko (2021). R package 'corrplot': Visualization of a Correlation Matrix (Version 0.92). Available from https://github.com/taiyun/corrplot
10.  Wickham H, Averick M, Bryan J, Chang W, McGowan LD, François R, Grolemund G, Hayes A, Henry L, Hester J, Kuhn M, Pedersen TL, Miller E, Bache SM, Müller K, Ooms J, Robinson D, Seidel DP, Spinu V, Takahashi K, Vaughan D, Wilke C, Woo K, Yutani H (2019). “Welcome to the tidyverse.” _Journal of Open Source Software_, *4*(43), 1686. doi:10.21105/joss.01686 <https://doi.org/10.21105/joss.01686>.
11.  Wickham H, François R, Henry L, Müller K (2022). _dplyr: A Grammar of Data Manipulation_. R package version 1.0.9, <https://CRAN.R-project.org/package=dplyr>.
12.  Wickham H, Girlich M (2022). _tidyr: Tidy Messy Data_. R package version 1.2.0, <https://CRAN.R-project.org/package=tidyr>.
13.  Wickham H, Seidel D (2022). _scales: Scale Functions for Visualization_. R package version 1.2.1, <https://CRAN.R-project.org/package=scales>.






  
